
có 2 cách truyền dữ liều từ controller qua view 
-	model
-	viewbag.WelcomString ="chào mừng bạn với ViewBag"





=======================================================================
-	lý thuyết, ví dụ, ứng dụng thực tiễn 

--- sbmjob command in as400 from C#
	public static bool RunCmd(string cmdText, iDB2Connection cn)
	{
		bool rc = true;

		// Construct a string which contains the call to QCMDEXC.
		string pgmParm = String.Format("CALL QSYS/QCMDEXC('{0}', {1})", 
						 cmdText.Replace("'", "''").Trim(), 
						 cmdText.Trim().Length.ToString("0000000000.00000"));

		using (cn)
		{
			using (iDB2Command cmd = new iDB2Command(pgmParm, cn))
			{
				try { cmd.ExecuteNonQuery(); }
				catch { rc = false; }
			}
		}

		// Return success or failure
		return rc;
	}
	
---	DataRow: Select cell value by a given column name
	DataRow row = table.Rows[0];
	string rowValue = row["ColumnName"].ToString();

	hoac 

	row.Field<type>("fieldName");
	

===================================================================
chuong trinh xep lich hotline
-	theo thu tu A B C D E F G
-		

-	giao diện có calendar chọn start date và end date chạy report
-	có edit text để gõ tên nhân viên vào
-	class nhanvien: ten, số lượng ngày trực, list ngay truc, cờ check trực CN 
-	get list tên nhân viên vào list nhanvien xử lí 
-	vòng lặp mỗi ngày check trên all nhân viên:
-	lấy min của all nhân viên
-	khai báo list nhanvien có ít ngày trực nhất
-	lưu all nhân viên có min vào list
-	lấy phần tử đầu tiên gán vào ngày trực
-	check ngày hiện tại có phải là thứ 7 không 
-	nếu ngày hiện tại là t7 thì gán 3 ngày T7 CN T2 vào người đó, không phải thì thôi
-	

-	lặp chạy all ngày:
	-	check nếu là t7 thì set vào nhan vien
	-	gán đến đâu thì xóa ngày thứ 7 vừa gán đó ra khỏi list date trực
-	lặp cho list ngày còn lại đã bỏ all t7 cn t2 
	-	Chỉ check trong từng tháng, không check all vì nếu check all 12 tháng sẽ sai => 1 người sẽ trực 6 ngày, có người cả tháng chỉ trực 2 ngày:
		-- =	lấy nhan vien có ngày trực >5 lưu vào listNhieu và <4 lưu vào listIt ra
		-- =	trừ số ngày trực của nhan vien listNhieu >5 về =5
		-- =	lưu số ngày trừ ra đó vào listThua ngày
		-- =	Cộng listThua vào list nhan vien listIt ngày đến =4 thì dừng 
	-	split ra n list tương ứng từng tháng 
	-	lặp tren từng tháng 
		=	khai báo list nhanvien có ít ngày trực nhất trong từng tháng đang xử lí 
		=	lưu all nhân viên có min vào list: lấy tổng ngày trực của từng nhân viên trong tháng, lấy giá trị min, lấy những nhân viên có ngày trực trong tháng đó là min, lưu all nhân viên đó vào list 
		=	lấy  ngày trực gán vào phần tử đầu tiên(đổi thành phần tử random) cửa list 
		=	lặp lại cho all ngày trong tháng cho đến hết tất cả các ngày trong tháng 
	-	lặp lại cho tháng kế tiếp, reset gán lại số ngày trực hiện tại 
	-	chạy theo nhiều năm: tách khoảng cách năm ra từng năm, sau đó chạy code cho mỗi năm riêng biệt
-	xắp xếp ngày trực của 1 nhân viên theo thứ tự đều 
-	xuất ra file 
-	lưu tất cả vào 1 tháng có thứ tự
	=	tạo biến list<Nhanvien>
	=	lưu tất cả ngày và tên người trực vào biến đó
	=	xắp xếp theo ngày tăng dần
	=	xuất ra kết quả theo từng tháng:


-	nếu ngày làm việc là ngày nghĩ thì người cầm trước đó sẽ cầm luôn:
	=	check nếu ngày tiếp theo là ngày nghĩ thì làm bên dưới 
	=	người hiện tại sẽ cầm hotline tiếp ngày đó
	=	số ngày trực tăng lên
	=	i trong vòng lặp tăng lêncv
	
-	nếu là 30/4 va 1/5 thi nguoi đó sẽ trực 2 ngày liên tục và được cộng thêm ngày

-	nếu ai trực lễ rồi thì không trực lần 2 nữa
-	ai trực lễ thì +2, 
-	làm động cho phép add ngày lễ vào
-	xuất ra báo cáo dạng excel hoặc calendar cho phép check số ngày


-	check CN => check ngày lễ => check ngày thường
-	check lễ: trong từng tháng 
-	khai báo List<list<ngay>> listNgayLe
-	gán all ngày lễ vào listNgayLe
-	sau khi check CN, ta check tiếp ngày lễ: 
	-	foreach từng phần tử trong listNgayLe
	-	nếu count(phần tử thứ i trong listNgayLe) là >1 (nếu ngày tiếp theo là ngày lễ)
		=	nếu trước ngày lễ là ngày làm việc bình thường:
			==	get all nhan vien không trực CN trong tháng chứa ngày lễ đó ra lưu vào list_Chưa_Trực_CN
			==	lấy random một nhanvien trong list_Chưa_Trực_CN 
			==	check nhanvien đó đã trực lễ chưa
			==	nếu chưa trực lễ thì mới gán ngày trực lễ
			==	nhan vien nào trực ngày lễ sẽ trực hết list lễ liên tục đó
			==	mỗi ngày lễ sẽ tính +2
			==	gán ngày trực vào list ngày trực của nhanvien đó
			==	gán cờ checkTrucLe = true
			==	remove ngày lễ đó ra khỏi listNgayLe
			==	gán một ngày thì i trong vòng lặp ngày tháng tăng 1: i++ 
		=	nếu trước ngày lễ là CN (ngày lễ là thứ 2) hoặc ngày lễ bắt đầu là thứ 6 
			==	check người nào trực CN đó
			==	gán list ngày trực liên tục đó cho người trực nhanvien
			==	lấy người nhanvien đó ra lưu vào nv
			-- ==	check nếu nv chưa trực lễ thì:
				-- ===	gán list ngày trực liên tục đó cho người trực nhanvien
			-- ==	nếu nv đó đã trực lễ thì ??????
	-	nếu count(phần tử thứ i trong listNgayLe) =1:
		=	nếu lễ là thứ 6, thì người trực CN sẽ trực luôn:  
			==	+2 số ngày trực cho người đó
			==	gán ngày trực vào list ngày trực của nhanvien đó
			==	bật cờ checkTrucLe = true 
			==	remove ngày lễ đó ra khỏi listNgayLe  
		=	nếu là T7 hoặc CN thì remove ngày đó ra khỏi listNgayLe:
			==	get ra nhan vien nào đã được set trực CN lễ đó
			==	bật cờ checkTrucLe=true
		=	nếu là những ngày còn lại (if else)
		
---	check ngay le 
-	khai báo thêm cho mỗi nhanvien: cờ checkTrucLe
-	check lễ: trong từng tháng
-	làm động cho việc khởi tạo list ngày lễ: cho user chọn add vô từng ngày 	 
-	khởi tạo list ngày lễ: hiện giờ làm tĩnh 
-	group by gôm nhóm all ngày lễ liên tục nhau thành một list con 
-	khai báo List<list<ngay>> listNgayLe:	var groups = new List<List<DateTime>>();
-	gán all list con ngày lễ vào listNgayLe
-	check CN => check ngày lễ => check ngày thường
-	lặp trên all phần tử listNgayLe	 
-	lấy phần tử lễ ra (phần tử này là list ngày)
-	n = count size phantu đó (đếm số ngày nghĩ trong lượt đó)
-	nếu n >= 2 
	-	nếu ngày đầu tiên trong phần tử đó là T6 T7 CN T2 thì người trực CN sẽ trực:
		=	get ngày CN trong tuần có ngày đầu tiên đó:	=======>>>>>>>> DateTime GetSunday(DateTime i, List<NhanVien> listNhanViens )
		=	check xem nhanvien nào đang trực ngày CN trên: 
			===	lặp trên mỗi nhanvien
			===	lặp trên mỗi ngày trực của List<DateTime> NgayTrucList của một nhanvien
			===	check nếu ngày trực nào bằng với i thì lấy nhanvien đó 
				=======>>>>>>>> goi ham NhanVien GetNhanVienDangTrucCnTruyenVao(DateTime i, List<NhanVien> listNhanViens )
		=	gọi hàm SetTrucLe(nhanvien,listNgayLe,allDateTimes)
	-	nếu ngày đầu tiên trong phần tử đó là:
		=	T3, nếu n<=3 thì bt: 
			==	get all người chưa trực lễ ra list: lặp trên all listNhanViens, nếu cờ checkTrucLe= false thì add vào listNhanVienChuaTrucLe
			==	random trong list đó, 
			==	gọi hàm SetTrucLe()
		=	T4, nếu n<=2 thì bt  
		=	T5, nếu n<=1 thì bt 
		=	còn lại thì người CN tuần đó sẽ trực 
	-	lấy list ngày nghĩ so với list ngày còn lại (sau khi check CN: đã bỏ ngày CN): nếu trùng ngày nào thì gán ngày đó cho người trực hotline và remove ngày đó ra khỏi list ngày còn lại và list ngày lễ
-	nếu còn lại (n=1)
	=	nếu là T6 T7 CN T2 thì người trực CN sẽ trực
		==	get ngày chủ nhật của tuần đó
		==	get nhân viên nào có ngày trực CN đó
		==	gán ngày lễ vào nhân viên đó
		==	+2 số ngày trực cho người đó
		==	remove ngày lễ khỏi list lễ
		==	remove ngày thường bằng ngày lễ đó  
	=	còn lại thì gán trực lễ cho all nhanvien nào chưa trực lễ:
		==	get all người chưa trực lễ ra list: lặp trên all listNhanViens, nếu cờ checkTrucLe= false thì add vào listNhanVienChuaTrucLe
		==	random trong list đó, 
		==	gọi hàm SetTrucLe()
		
-	hàm gán nhân vien trực lễ public static void SetTrucLe(NhanVien aNhanVien, List<DateTime> listNgayLe, List<DateTime> allDateTimes):
	=	lặp trên all phan tử listNgayLe
		==	gán ngày trực cho nhanvien
		==	+2 số ngày trực cho nhanvien
		==	bật cờ checkTrucLe = true
		==	remove khỏi list allDates(sau khi đã check CN) theo ngày lễ đó: update ngày đó thành eventsInYear[i] = new DateTime(2000, 01, 01): kiếm index của phần tử trong list ngày có giá trị bằng với ngày lễ, update ngày đó thành DateTime(2000, 01, 01) dựa theo index đó 
		-- ==	tìm trong listNhanViens xem element nhanvien nào bằng với aNhanVien
		-- ==	update element nhanvien đó theo aNhanVien: cộng dồn số lượng ngày trực, cộng dồn ngày trực, update cờ checkTrucLe 
		
-	bị trùng xử lí CN và ngày lễ:
	=	get index cho list all ngày lễ theo allDates
	=	sau khi xu li CN
	=	check xem nếu allDates[index] = năm 2000 thì có nghĩa là CN đã gán rồi
	=	thì remove ngày lễ đó ra khỏi list ngày lễ
	=	sau đó mới xử lí lễ 
	
-	count,index,list ngày lễ 

-	check lại hàm check nhan vien nao đang trực CN 
-	sua lai phan update: nếu là t7 cn t2 thì không add thêm ngày vào nữa vì đã được gán cho người trực CN rồi, ngày t6 thì mới gán thêm vào.
	=	nếu là t7 cn t2 thì chỉ +1 số ngày, gán cờ checkTrucLe=true, không cộng dồn ngày vì đã check CN rồi 
	=	check lại việc check nhanvien nào trực CN của tuần chứa ngày truyền vào 
	
-	check lai ham GetSunday() bi sai 

-	lúc check ngày thường:
	=	đếm số ngày trực của mỗi người 
	=	lặp trên mọi người
	=	đếm số ngày của mỗi người
	=	nếu là ngày lễ thì: -1 và +2 số lượng ngày 
	
-	check lai xem đếm số ngày lễ lúc get nhanvien trực ít nhất ra đúng ko
-	check lại việc gán lễ luân phiên nhau 

-	ngày nghĩ cuối cùng là 2/9 thì người trực sẽ cầm thêm ngày 3/9 luôn vì 2/9 không đi làm nên không giao ca được, vì vậy sẽ cộng thêm 1 ngày trực nữa vào cuối ngày nghĩ lễ cho ai đang cầm hotline 
	
-	check lại aNhanVien.soNgayTrucHotline với số ngày trực trong 1 tháng trong hàm SetTrucLe()
-	check thử việc nhập khoản thời gian từ ngày 26/9/2016 đến ngày 5/1/2017: tìm cách cho nó ghép được CN cuối giữa 2 năm 2016 và 2017. 

-	Tìm cách gán nếu nhập vào khoản thời gian nhưng ngày đầu tiên của khoản đó là CN T2 => tìm cách nếu có đủ T7 CN t2 thì set bình thường nhưng nếu chỉ có 
	=	lấy phần tử đầu tiên
	=	check nếu là ngày 1/1
		=	trừ 1 ngày
		=	check xem ngày lùi đó nếu là T7 CN thì:
			=	get nhanvien nào trực CN đó
			=	gán cho nhanvien đó
			=	update thành năm 2000 cho ngày vừa gán cho nhanvien đó 
			
			
-	them co check truc trong tuan: neu trong tuan da truc roi thi no se bo qua: 
	= 	tạo cờ i check gọi hàm gán ngày trực
	=	mỗi lần gán ta sẽ +1, và lưu người được gán trực vào list temp
	=	nếu i<=7 và nhân viên a đã có trong list temp và số lượng nhân viên trong list nhân viên trực ít nhất >=2: 
		==	thì bỏ qua get nhân viên khác: remove người đó khỏi list nhân viên trực ít nhất, get random bất kì trong list nhân viên trực ít nhất, gán ngày trực cho nhanvien vừa get ra đó 
		==	nếu else không thỏa điều kiện trên thì gán bình thường 
	=	nếu i=7 thì reset i=0, clear list temp
	=======>>>>>>>> SAI CMNR
	
-	check mỗi ngày
	=	check CN trước nó và CN sau nó
	=	get 2 nhanvien trực 2 CN đó ra 
	=	check trong list nhanvien trực ít nhất, nếu có 2 người CN đó và số người trong list >=3 thì remove ra khỏi list
	=	sau đó gán bình thường 
	

/* -	chia để trị xếp lịch:
	=	chia thời gian thành n tuần
	=	mỗi tuần chạy giải thuật gán ngày trực:
		==	gán ngày thường
		==	gán chủ nhật
	=	tổng hợp kết quả của n tuần  */
		
/* -	chia để trị dàn trải đều ngày trực:
	=	chia 1 tháng thành 4 tuần
		==	chia 1 tháng ra 4 tuần, mỗi phần tử chia ra là 1 list ngày 
			===	lặp từ ngày đầu tháng đến ngày cuối tháng
			===	cộng ngày đầu tiên đến ngày CN và lưu kết quả vào list<DateTime> a
			===	for (i=0; i<=so_ngay_trong_thang-1; i++)
					-	nếu i là ngày thứ 2 thì n là 7
										  3 thì n là 6
										  4 thì n là 5 	
					-	new list<DateTime> 
					-	for(j=0; j<n-1;j++)
							add ngày i vào list<DateTime> 
							i++
							addDate(1)
					-	add list<DateTime> vào list<list<DateTime>> date
			
		==	lưu all phần tử vào list<List<DateTime>> dateByWeek
	=	mỗi tuần gọi hàm dàn trải đều: -- foreach tuần trong dateByWeek 
		==	check từ thứ 2 đến thứ 7
		==	1 tuần phải có 6 người khác nhau thì mới đúng 
		==	trong mỗi tuần, check nhân viên nào trực >=2 lần trong tuần:
			===	lặp trên mỗi nhân viên 
			=== int a = select count(*) from listNgayTruc where ngayTruc between dauTuan and CuoiTuan
			===	nếu a >=2 thì lưu nhanvien đó vào list_NhanVien_duplicate
		==	lưu all nhanvien đó vào list_NhanVien_duplicate(đây là list nhanvien gồm tên và ngày trực trong tuần đang check)
		==	nếu count(list_NhanVien_duplicate) >= 1
			==	lấy ra list_nhanvien_chua_co_trong_tuan(list này là list nhanvien: gồm tên và ngày trực trong tháng đang check) chưa có trực trong tuần đó 
			==	foreach trong list_NhanVien_duplicate:
				===	(nếu count>=1)lấy phần tử đầu tiên của list_nhanvien_chua_co_trong_tuan và remove nhân viên đó ra khỏi list_nhanvien_chua_co_trong_tuan 
				===	get all ngày trực 1 nhanvien trong tháng chỉ định => từ đó get all ngày trực 1 nhanvien không có trong tuần chỉ định: 
				===	swap ngày trực của 2 nhanvien trong list_NhanVien_duplicate trong vòng foreach và nhanvien trong list_nhanvien_chua_co_trong_tuan(ngày tương ứng trong tháng đang check) vừa get ở bước trên 
	=	tổng hợp lại kết quả  */

/* -	dàn trải ngày trực cho đều
	=	tạo listTempNV size = 7 
	=	lưu tên 7 nhanvien vào listTempNV
	=	trong vòng lặp mỗi ngày: 
	=	nếu count(listTempNV) = 0 thì 
		=	add 7 nhanvien vào listTempNV, trộn listTempNV 
		foreach listTempNV
			=	check nếu nhanvien.SoNgayTruc trong tháng đó <= 5 (số ngày trực tối đa trong tháng của 1 nhanvien):
				==	gán ngày trực cho nhanvien đó
				==	và remove phần tử đó ra khỏi listTempNV
				==	break khỏi foreach 
			=	nếu nhanvien đó > 5:
				==	thì remove phần tử đó ra khỏi listTempNV, 
				==	continue foreach		
	=	nếu count(listTempNV)>=1 thì
		foreach listTempNV
			=	check nếu nhanvien.SoNgayTruc trong tháng đó <= 5 (số ngày trực tối đa trong tháng của 1 nhanvien):
				==	get first() của listTempNV
				==	get nhanvien from list nhanvien a có name = listTempNV.fist().name
				==	gán ngày trực cho nhanvien trong list a đó
				==	và remove phần tử đó ra khỏi listTempNV
				==	break khỏi foreach 
			=	nếu nhanvien đó > 5:
				==	thì remove phần tử đó ra khỏi listTempNV, 
				==	continue foreach */
			

/* -	tạo list index kiểu int từ 0 -> count(list nhanvien)-1 
-	trộn list index đó
-	nếu count(list index) = 0 thì:
	=	tạo data cho list đó từ 0->7
	=	gọi hàm CheckAndSetTruc
-	nếu count(list index) > 0 thì gọi hàm CheckAndSetTruc
-	viết hàm CheckAndSetTruc có 3 tham số: list index, list nhanvien, ngày đang gán trực
	=	lấy phần tử đầu tiên của list index lưu vào int index
	=	remove phần tử đó ra khỏi list index
	=	gọi hàm CountNgayTrucByMonth(nhanvien[index],ngày đang gán)
	=	nếu số ngày làm việc của nhanvien đó >5 thì bỏ qua: return luôn 
	=	nếu số ngày làm việc của nhanvien đó <=5:
		=	thì gán ngày trực cho nhanvien[index] đó
		=	và return hàm luôn 
-	nếu số ngày trực là 4 thì không làm gì cả và đẩy nhanvien đó vào list2 
-	nếu all nhanvien đều trực 4 ngày rồi thì mình mới gọi hàm CheckAndSetTruc2 giới hạn thêm 1 ngày nữa 
	
-	nếu trực lien tiep thì bỏ qua
-	nếu chưa trực liên tiếp thì gán vào  */


-	lặp cho all nhanvien có ít ngày trực nhất 
	=	check xem nhanvien nào trực lien tiếp rồi thì bỏ ra khỏi list nhanvien trực ít nhất
		=	lặp từ 1->7
		=	mỗi lần lặp dday = addDate(-1)
		=	check ngày dday có nằm trong list ngày trực của nhanvien đang check hay không
			=	nếu có trong list ngày trực thì remove nhanvien đó khỏi list nhanvien trực ít nhất
			=	nếu không có thì bỏ qua không làm gì cả 
-	sau đó gán ngày trực bình thường  


---	select from list C# and get 
if ((lstNhanViensAll.Where(x => x.ten == i.ten).FirstOrDefault().NgayTrucList.Contains(tmpDateTime)) && (lstNhanVienTrucMin.Count>1))
                        {
                            lstNhanVienTrucMin.Remove(i);
                        }
						
---	var to List<T> conversion
var selected = from s in studentCollection
                           select s;

List<Student> selectedCollection = selected.ToList();


---To get First Date
	public DateTime FirstDayOfMonth(DateTime dateTime)
	{
	   return new DateTime(dateTime.Year, dateTime.Month, 1);
	}
	---	To get Last Date
		public DateTime LastDayOfMonth(DateTime dateTime)
		{
		   DateTime firstDayOfTheMonth = new DateTime(dateTime.Year, dateTime.Month, 1);
		   return firstDayOfTheMonth.AddMonths(1).AddDays(-1);
		}

---	find index of an int in a list
	// given list1 {3, 4, 6, 5, 7, 8}
	list1.FindIndex(x => x==5);  // should return 3, as list1[3] == 5;
	Or
	var index = myList.FindIndex(a => a.Prop == oProp);
---	How do I copy items from list to list without foreach?		
	You could try this:
		List<Int32> copy = new List<Int32>(original);
	
	or if you are using C# 3 and .NET 3.5, with Linq, you can do this:
		List<Int32> copy = original.ToList();

--In C#, what is the best way to group consecutive dates in a list?
http://stackoverflow.com/questions/27393626/in-c-what-is-the-best-way-to-group-consecutive-dates-in-a-list
	//Dates for testing
	 List<DateTime> dates = new List<DateTime>()
	 { 
		  new DateTime(2013,12,31),
		  new DateTime(2014,2,2),
		 new DateTime(2014,1,1),
		 new DateTime(2014,1,2),
		 new DateTime(2014,2,1),               
		 new DateTime(2014,2,16),
		 new DateTime(2014,3,13),
	 };
	 
	 dates.Sort();
	 //this will hold the resulted groups
	 var groups = new List<List<DateTime>>();
	 // the group for the first element
	 var group1 = new List<DateTime>(){dates[0]};
	 groups.Add(group1);

	 DateTime lastDate = dates[0];
	 for (int i = 1; i < dates.Count; i++)
	 {
		 DateTime currDate = dates[i];
		 TimeSpan timeDiff = currDate - lastDate;
		 //should we create a new group?
		 bool isNewGroup = timeDiff.Days > 1;
		 if (isNewGroup)
		 {
			 groups.Add(new List<DateTime>());
		 }
		 groups.Last().Add(currDate);
		 lastDate = currDate;
	 }

---Combining consecutive dates into ranges
http://stackoverflow.com/questions/19433189/combining-consecutive-dates-into-ranges

--Get the Monday and Sunday for a certain DateTime in C#
http://stackoverflow.com/questions/4139287/get-the-monday-and-sunday-for-a-certain-datetime-in-c-sharp
	DateTime d = DateTime.Today;
	// lastMonday is always the Monday before nextSunday.
	// When today is a Sunday, lastMonday will be tomorrow.     
	int offset = d.DayOfWeek - DayOfWeek.Monday;     
	DateTime lastMonday = d.AddDays(-offset);
	DateTime nextSunday = lastMonday.AddDays(6);
	
--how to check if object already exists in a list
	---Check if date exist in list of dates
	DateTime date_1 = new DateTime(2016, 1, 1); 
	bool exist = dates.Any (d => d.Month == date_1.Month && d.Day == date_1.Day);
	Console.WriteLine(exist);

	DateTime date_3 = new DateTime(2016, 1, 2); 
	exist = dates.Any (d => d.Month == date_3.Month && d.Day == date_3.Day);
	Console.WriteLine(exist);

	Item wonderIfItsPresent = ...
	bool containsItem = myList.Any(item => item.UniqueProperty == wonderIfItsPresent.UniqueProperty);

	bool alreadyExists = myList.Any(x=> x.Foo=="ooo" && x.Bar == "bat");
	bool alreadyExist = list.Contains(item);
		
	

	

-	check ngày trực lễ trước:
	=	check trong mỗi tháng
	=	nhanvien nào chưa trực CN thì lấy ra đổ vào lstNhanVienTrucLe
	=	lấy random trong lstNhanVienTrucLe lưu vào nv 
	=	gán ngày lễ cho nv đó
	=	update lại số ngày trực, cờ trực lễ, ngày trực của nv đó
	=	nếu 



	
=======================================================================
ICS832
-	nhập item và get item vào chương trình
-	select từ IA theo item để get item,whs,locn,isl#,qty: select va luu vao list item 
-	select từ lb theo item,whs,locn,isl#,qty mà get từ IA: select tu bang LB va luu vao list2 item  
-	nếu IA và LB bằng nhau thì bỏ qua, nếu khác nhau thì thực hiện update 5 bảng cho allocate và pick theo IA
-	nếu IA và IW bằng nhau scheduled thì bỏ qua, nếu khác nhau thì update 2 bảng IW và IM theo IA
-	check lai scheduled, neu IMSSA != IWSSA thi update IMSSA = IWSSA
		select sum (IMSSA) as IMSSA from IM where item ='N13G0009'                
		select sum (IWSSA) as IWSSA from IW	where item ='N13G0009'   
-	check IWSSA những line bị scheduled trong IW mà trong IA không có
	=	select scheduled <> 0 trong IW của item và all whS
	=	check line nào không có trong ia
	=	nếu những line mà không có trong ia có scheduled <>0 thì ta update lại cho nó =0

Xem ICS552 để biet lenh Shift F8
select a.ttype,a.batch,AJDSTS,a.item           
from ASLF0183 a, AJD b                         
where a.item='M070310'                         
and a.ttype ='LT'                              
and a.ttype =b.ttype and a.batch=b.batch       
and AJDDEL='' and  IADEL=''                                 
and AJDSTS <> '2'                              
and a.bhseq=b.bhseq          

select a.ttype,a.batch,AJDSTS,a.item 
from AS400.S064BE8R.ZPTLIBD.ASLF0183 a, AS400.S064BE8R.ZPTLIBD.AJD b                         
where a.item='M070310' and a.ttype ='LT'                              
and a.ttype =b.ttype and a.batch=b.batch       
and AJDDEL='' and  IADEL='' and AJDSTS <> '2'                              
and a.bhseq=b.bhseq

Cach 2:
-	nhập item và get item vào chương trình
-	select từ IA ttype in (OR,PS) theo item để get item,whs,locn,isl#,qty: select va luu vao list item
-	trong mỗi line IA, check:
	=	nếu locn='Scheduled': update IWSSA, IMSSA cho IW, IM theo item,whs của IA 
	=	picked locn='PICKED': update LBSPK 5 bảng theo item,whs,locn,isl# IA 
	=	còn lại là allocate: update LBSOA 5 bảng theo item,whs,locn,isl# IA 
-	check scheduled locn ='Scheduled' 
	=	select scheduled <> 0 trong IW của item và all whS
	=	check line nào có trong IW và IA (điều kiện link là item và whs), update lại scheduled trong IW theo IA 
	=	check line nào không có trong ia, update lại scheduled trong IW cho nó =0: tức là trừ đi lượng scheduled cho 2 bảng IW và IM 
	
-	check allocate ttype in (OR,PS), locn khác 'PICKED' và 'Scheduled' 
	=	select allocate <> 0 trong LB của item và all whS
	=	check line allocate có trong LB và IA theo điều kiện (item,whs,locn,isl#): update LBSOA 5 bảng theo IA 
	=	check line allocate có trong LB mà không có trong IA: update trừ đi phần allocate trong 5 bảng cho nó về 0

-	check picked ttype in (OR,PS), locn ='PICKED' 
	=	select LBSPK<>0 trong LB của của item và all whS
	=	line picked có trong LB và IA theo điều kiện (item,whs,locn,isl#):update LBSPK 5 bảng theo IA 
	(=	line picked có trong LB mà không có trong IA: update trừ đi phần LBSPK trong 5 bảng cho nó về 0)

Cach 3
-	nhập item và get item vào chương trình
-	select từ IA ttype in (OR,PS) theo item để get item,whs,locn,isl#,qty: select va luu vao list item
-	select từ IA ttype in LT theo item câu lệnh mới để get item,whs,locn,isl#,qty: select va luu vao list item
-	check allocate 
	=	select allocate <> 0 trong LB của item và all whS
	=	mass update allocate <> 0 cua item đó về 0
	=	select allocate <> 0 trong 4 bảng còn lại IL, ISL#, IW, IM 
	=	mass update allocate <> 0 cua item đó về 0
	-- =	check nếu sum allocate 3 bảng lb, il, isl =0 thì check tiếp nếu iw có allocate<>0 thì select trong iw xem có allocate<>0 thì update all trừ cho nó = 0; rồi update im allocate=0
		-- ===	sum allocate 5 bảng
		-- ===	nếu lb il isl =0 và iw <>0: select allocate from iw wher allocate<>0; update về 0 cho allocate trong iw; update allocate cho im về 0 
-	check picked
	=	select LBSPK<>0 trong LB của của item và all whS
	=	mass update PICKED <>0 của item đó về 0
	=	select PICKED <> 0 trong 4 bảng còn lại IL, ISL#, IW, IM 
	=	mass update PICKED <> 0 cua item đó về 0
	-- =	check nếu sum picked 3 bảng lb, il, isl =0 thì check tiếp nếu iw có picked<>0 thì select trong iw xem có picked<>0 thì update all trừ cho nó = 0; rồi update im picked=0
		-- ===	sum picked 5 bảng
		-- ===	nếu lb il isl =0 và iw <>0: select picked from iw wher picked<>0; update về 0 cho picked trong iw; update picked cho im về 0 
-	check scheduled 
	=	select scheduled <> 0 trong IW,IM của item và all whS
	=	mas update scheduled<>0 của item đó trong file IW,IM về 0
-	lặp trên all line của list item:
	=	nếu locn='Scheduled': update IWSSA cho IW item,whs của IA. Rồi update IMSSA = sum(IWSSA) của item đó
	=	picked locn='PICKED': update LBSPK 5 bảng theo item,whs,locn,isl# IA 
	=	còn lại là allocate: update LBSOA 5 bảng theo item,whs,locn,isl# IA 

-	sum allocate 5,picked 5, scheduled
-	check nếu sum allocate 5 bảng = nhau thì xuất ra "allocate đã đúng", nếu 5 bảng không bằng nhau thì xuất ra "allocate 5 bảng không bằng nhau. Fix tay tiếp nhé"
-	check nếu sum picked 5 bảng = nhau thì xuất ra "picked đã đúng", nếu 5 bảng không bằng nhau thì xuất ra "picked 5 bảng không bằng nhau. Fix tay tiếp nhé"
-	check nếu sum scheduled 2 bảng IW và IM: nếu bằng nhau thì xuất ra "scheduled đã đúng", nếu 2 bảng không bằng nhau thì xuất ra "scheduled 2 bảng không bằng nhau. Fix tay tiếp nhé"


-	get allocate và picked <> 0 trong IL
	=	select item,locn,whs,ilsoa,ilspk from il where (ilsoa<>0 or ilspk<>0) and item='A'
	=	run sql, lưu vào datatable
	=	lưu vào list<item> il
	=	lặp trên all list item il 
	=	update ilsoa,ilspk = 0 theo ITEM,LOCN,WHS của mỗi phần tử trong list il 

-	get allocate và picked <> 0 trong ISL#
	=	select item,ISL#,ISLsoa,ISLspk from ISL# where (ISLsoa<>0 or ISLspk<>0) and item='A'
	=	run sql, lưu vào datatable
	=	lưu vào list<item> ISL 
	=	lặp trên all list item ISL 
	=	update ISLsoa,ISLspk = 0 theo ITEM,ISL# của mỗi phần tử trong list ISL 
	
-	get allocate và picked <> 0 trong IW
	=	select item,IW,iwsoa,iwspk from IW where (iwsoa<>0 or iwspk<>0) and item='A'
	=	run sql, lưu vào datatable
	=	lưu vào list<item> IW
	=	lặp trên all list item IW 
	=	update iwsoa,iwspk = 0 theo ITEM,WHS của mỗi phần tử trong list IW 
	
-	get allocate và picked <> 0 trong IM
	=	select item,imsoa,imspk from IM where (imsoa<>0 or imspk<>0) and item='A'
	=	run sql, lưu vào datatable
	=	update imsoa,imspk = 0 theo ITEM của mỗi phần tử trong list IW 
	
-	sum allocate trong ia theo item	
-	sum picked trong ia theo item
-	sum scheduled trong ia theo item


Check them type BI 

 Item                  Warehouse                                   
 S300260               WM1                                         
                    Item Warehouse Allocations                     
      --- Ref# ---  Quantity    Serial/Lot#     Location     Whs   
  01  BI 88271863     9119.000                  Scheduled    WM1   
  02  BP 61013156     1350.000  6S088           B14-07-03-02 WM1 

select ITEM, WHS, IWTIN,IWTOUT
			from IW 
			WHERE ITEM='S300260'
			AND WHS='WM1'

 ITEM                  WHS           IWTIN           IWTOUT  
 S300260               WM1            .000       10469.000  
 
 update IW set IWTOUT=IWTOUT-10469
	WHERE ITEM='S300260'
	AND WHS='WM1' 
	
	
UPDATE LB                     UPDATE LB 
SET  LBSOA= LBSOA-300         SET  LBSOA= LBSOA + {0}                            
WHERE ITEM='P070050'          WHERE ITEM='{1}' 
AND LOCN='C2-P1-1-1'          AND LOCN='{2}' 
AND ISL#='A300840'            AND ISL#='{3}' 
AND WHS='AS4'                 AND WHS='{4}'                                                

	UPDATE IL SET ILSOA=ILSOA-300       UPDATE IL SET ILSOA=ILSOA + {0}             
	WHERE ITEM='P070050'                WHERE ITEM='{1}' 
	AND LOCN='C2-P1-1-1'                AND LOCN='{2}'
	AND WHS='AS4'                       AND WHS='{3}'  

		UPDATE ISL                       UPDATE ISL                          
		SET ISLSOA=ISLSOA-300            SET ISLSOA=ISLSOA + {0}              
		WHERE ITEM='P070050'             WHERE ITEM='{1}' 
		AND ISL#='A300840'				 AND ISL#='{2}'						 
			 
			UPDATE IW SET IWSOA=IWSOA-300   UPDATE IW SET IWSOA=IWSOA + {0}   
			WHERE ITEM='P070050'            WHERE ITEM='{1}' 
			AND WHS='AS4'                   AND WHS='{2}'                              

				UPDATE IM SET IMSOA=IMSOA-300    UPDATE IM SET IMSOA=IMSOA + {0} 
				WHERE ITEM='P070050'             WHERE ITEM='{1}'    


ITEM	WHS	LOCN				ISL#	LBSOA
A121010	WH6	B13-11-01-01	ZABL	198

LB
select ITEM, LOCN, ISL#, WHS, LBSOA
from LB	
WHERE ITEM='A121010' 
AND LOCN='B13-11-01-01' 
AND ISL#='ZABL' 
AND WHS='WH6' 

UPDATE LB 
SET  LBSOA= LBSOA-5                                    
WHERE ITEM='A121010' 
AND LOCN='B13-11-01-01' 
AND ISL#='ZABL' 
AND WHS='WH6'    

	select sum(LBSOA) from LB where ITEM='A121010'
	select sum(ILSOA) from IL where ITEM='A121010'
	select sum(IWSOA) from IW where ITEM='A121010'
	select sum(ISLSOA) from ISL where ITEM='A121010'
	select sum(IMSOA) from IM where ITEM='A121010'
	
	select sum (IMSSA)
from IM where item ='A121010'                
		  
select sum (IWSSA)
from IW	where item ='A121010'   


--- update picked
UPDATE LB 
SET  LBSPK= LBSPK+300                                    
WHERE ITEM='A121210' 
AND LOCN='PICKED' 
AND ISL#='KE560'
AND WHS='WH1'
 
		UPDATE ISL                                   
		SET ISLSPK=ISLSPK + 300                        
		WHERE ITEM='A121210' 
		AND ISL#='KE560'
		
				UPDATE IL SET ILSPK=ILSPK+300                 
				WHERE ITEM='A121210' 
				AND LOCN='PICKED' 
				AND WHS='WH1' 
 
						UPDATE IW SET IWSPK=IWSPK+100   
						WHERE ITEM='A121210' 
						AND WHS='WH1' 
 
			 
								 UPDATE IM SET IMSPK=IMSPK+100
								WHERE ITEM='A121210'  


======================================================================

-	sum list 
		int sumAllocate=0, sumScheduled=0, sumPicked =0;
            foreach (Item item1 in items)
            {
                if (item1.LOCN == "Scheduled")
                {
                    sumScheduled = sumScheduled + item1.IAQA;
                }
                else if (item1.LOCN == "PICKED")
                {
                    sumPicked = sumPicked + item1.IAQA;
                }
                else
                {
                    sumAllocate = sumAllocate + item1.IAQA;
                }
            }            
	
------------------------------
-	Getting all DateTimes between two 'DateTime's in C#
public void GetAllDatesAndInitializeTickets(DateTime startingDate, DateTime endingDate)
    {
        List<DateTime> allDates = new List<DateTime>();

        int starting = startingDate.Day;
        int ending = endingDate.Day;

        for (int i = starting; i <= ending; i++)
        {
            allDates.Add(new DateTime(startingDate.Year, startingDate.Month, i));
        }

for (DateTime date = startingDate; date <= endingDate; date = date.AddDays(1))
    allDates.Add(date);

	
-	check thu 7 CN
if (startdate.DayOfWeek == DayOfWeek.Saturday)
    startdate = startdate.AddDays(2);
else if (startdate.DayOfWeek == DayOfWeek.Sunday)
    startdate = startdate.AddDays(1);


-	c# remove item from list
var itemToRemove = resultlist.Single(r => r.Id == 2);
resultList.Remove(itemToRemove);

-	Find element in List<> that contains value
var value = MyList.First(item => item.name == "foo").value;
var value = MyList.Find(item => item.name == "foo").value;


-	sort list object c#
List<Leg> legs = GetLegs()
                .OrderBy(o=>o.Day)
                .ThenBy(o=>o.Hour)
                .ThenBy(o=>o.Min).ToList();
List<Order> SortedList = objListOrder.OrderBy(o=>o.OrderDate).ToList();


-	compare month
var yourDate = ...;
var lowerBoundYear = 2011;
var lowerBoundMonth = 1;
var upperBoundYear = 2012;
var upperBoundMonth = 4;
if(((yourDate.Year == lowerBoundYear && yourDate.Month >= lowerBoundMonth) || 
    yourDate.Year > lowerBoundYear
   ) &&
   ((yourDate.Year == upperBoundYear && yourDate.Month <= upperBoundMonth) ||
    yourDate.Year < lowerBoundYear
   ))
{


-	select from list 
using System.Data.Linq;
var result = from i in list
             where i.age > 45
             select i;
// Find all the people older than 30
var query1 = list.Where(person => person.Age > 30);

// Find each persons name
var query2 = list.Select(person => person.Name);

==================================================================
MVC note
---	chuong trinh freaking match
+ Tạo ngẫu nhiên các phép toán cộng trừ và có hiển thị kết quả ngẫu nhiên
+ Nguời chơi nhấn phím Left - Right trên bàn phím để chọn đúng sai cho biểu thức:
	-	nếu đúng thì qua câu tiếp và +1 điểm
	-	nếu sai hoặc hết giờ thì dừng trò chơi và show điểm
+ Sau 1 lần chọn đúng + 1 điểm
+ Có tính thời gian mỗi phép tính

	// tạo số ngẫu nhiên
		r = new Random();
		int t = r.Next(1, 5);
		if (r.Next(0, 9) % 2 == 0 )
		{
			lbdau.Text = "-";
		}
		else {
			lbdau.Text = "+";
		}
		KiemTraDau();
		lb_so1.Text = r.Next(0, 9).ToString();
		lb_so2.Text = r.Next(0, 9).ToString();
				
		// chỉnh xác suất ra kết quả đúng
		if (t % 2 == 0) //(t == 2 || t == 4 ||t==3 )
		{	
			if (cong) lb_kq.Text = (int.Parse(lb_so1.Text) + int.Parse(lb_so2.Text)).ToString();
			else if (tru) lb_kq.Text = (int.Parse(lb_so1.Text) - int.Parse(lb_so2.Text)).ToString();
		}
		else
			lb_kq.Text = r.Next(0, 18).ToString();

---	Entity Framework (EF) Documentation
https://msdn.microsoft.com/vi-vn/data/ee712907

---	connectionStrings cho file app config. SchoolContext là tên file class SchoolContext: DbContext
<connectionStrings>
//connectionStrings không dùng user và password
<add name="SchoolContext" connectionString="Data Source=VNZPDPLE22;Initial Catalog=SchoolContextDataBase;Integrated Security=true;" providerName="System.Data.SqlClient" />

//connectionStrings có user và password
<add name="SchoolContext" connectionString="Server=VNZPDPLE22;Database=SchoolContextDataBase;user=sa;password=12345" providerName="System.Data.SqlClient" />
</connectionStrings>

---	entity framework code first chưa có database ban đầu - tao database from code first
-	khai báo lớp (lớp này tương đương với một dòng data trong một bảng sql)
	public class Student
    {
        public Student()
        {
        }
        public int StudentID { get; set; }
        public string StudentName { get; set; }
        public DateTime? DateOfBirth { get; set; }
        public byte[] Photo { get; set; }
        public decimal Height { get; set; }
        public float Weight { get; set; }

        public Standard Standard { get; set; }
    }
	
	public class Standard
    {
        public int StandardId { get; set; }
        public string StandardName { get; set; }

        public ICollection<Student> Students { get; set; }

    }
	
-	khai báo lớp thừa kế từ lớp DbContext và có chứa các lớp ở trên ===> class SchoolContext: DbContext
    public class SchoolContext: DbContext
    {
        public SchoolContext() : base()
        {
        }
        public DbSet<Student> Students { get; set; } --- Students là tên bảng sẽ tạo ra trong SQL 
        public DbSet<Standard> Standards { get; set; } --- Standards là tên bảng sẽ tạo ra trong SQL 
    }
-	hàm main gọi 
	public class HomeController : Controller
		{
			public ActionResult Index()
			{
				using (var ctx = new SchoolContext())
				{
					Student stud = new Student() { StudentName = "New Student" };

					ctx.Students.Add(stud);
					ctx.SaveChanges();
				}
				return View();
			}
		}
		
====================================================================
Checking Sent Email Messages on SQL Server

SENT MESSAGES LOG


	SELECT TOP 20 *
	FROM [msdb].[dbo].[sysmail_sentitems]
	ORDER BY [send_request_date] DESC

FAILED MESSAGES LOG


	SELECT TOP 20 *
	FROM [msdb].[dbo].[sysmail_faileditems]
	ORDER BY [send_request_date] DESC

ALL MESSAGES – REGARDLESS OF STATUS


	SELECT TOP 20 *
	FROM [msdb].[dbo].[sysmail_allitems]
	ORDER BY [send_request_date] DESC
===================================================================
How to configure SQL Server Database Mail to send email using your Windows Live Mail Account or your GMail Account
https://blogs.msdn.microsoft.com/suhde/2009/07/12/how-to-configure-sql-server-database-mail-to-send-email-using-your-windows-live-mail-account-or-your-gmail-account/
